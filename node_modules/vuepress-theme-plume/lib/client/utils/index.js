import { isLinkHttp, removeEndingSlash, removeLeadingSlash } from "vuepress/shared";
import { ensureEndingSlash, ensureLeadingSlash, isLinkAbsolute, isLinkWithProtocol } from "@vuepress/helper/client";
import { resolveRoute } from "vuepress/client";

//#region src/client/utils/resolveRepoType.ts
function resolveRepoType(repo) {
	if (!isLinkHttp(repo) || /github\.com/.test(repo)) return "GitHub";
	if (/bitbucket\.org/.test(repo)) return "Bitbucket";
	if (/gitlab\.com/.test(repo)) return "GitLab";
	if (/gitee\.com/.test(repo)) return "Gitee";
	return null;
}

//#endregion
//#region src/client/utils/resolveEditLink.ts
const editLinkPatterns = {
	GitHub: ":repo/edit/:branch/:path",
	GitLab: ":repo/-/edit/:branch/:path",
	Gitee: ":repo/edit/:branch/:path",
	Bitbucket: ":repo/src/:branch/:path?mode=edit&spa=0&at=:branch&fileviewer=file-view-default"
};
function resolveEditLinkPatterns({ docsRepo, editLinkPattern }) {
	if (editLinkPattern) return editLinkPattern;
	const repoType = resolveRepoType(docsRepo);
	if (repoType !== null) return editLinkPatterns[repoType];
	return null;
}
function resolveEditLink({ docsRepo, docsBranch, docsDir, filePathRelative, editLinkPattern }) {
	if (!filePathRelative) return null;
	const pattern = resolveEditLinkPatterns({
		docsRepo,
		editLinkPattern
	});
	if (!pattern) return null;
	return pattern.replace(/:repo/, isLinkHttp(docsRepo) ? docsRepo : `https://github.com/${docsRepo}`).replace(/:branch/, docsBranch).replace(/:path/, removeLeadingSlash(`${removeEndingSlash(docsDir)}/${filePathRelative}`));
}

//#endregion
//#region src/client/utils/resolveNavLink.ts
/**
* Resolve NavLink props from string
*
* @example
* - Input: '/README.md'
* - Output: { text: 'Home', link: '/' }
*/
function resolveNavLink(link) {
	const { notFound, meta, path } = resolveRoute(link);
	return notFound ? {
		text: path,
		link: path
	} : {
		text: meta.title || normalizeTitleWithPath(path),
		link: path,
		icon: meta.icon,
		badge: meta.badge
	};
}
function normalizeTitleWithPath(path) {
	path = path.replace(/index\.html?$/i, "").replace(/\.html?$/i, "").replace(/\/$/, "");
	return decodeURIComponent(path.slice(path.lastIndexOf("/") + 1));
}
function normalizeLink(base = "", link = "") {
	return isLinkAbsolute(link) || isLinkWithProtocol(link) ? link : ensureLeadingSlash(`${base}/${link}`.replace(/\/+/g, "/"));
}
function normalizePrefix(base, link = "") {
	return ensureEndingSlash(normalizeLink(base, link));
}

//#endregion
//#region src/client/utils/shared.ts
const EXTERNAL_URL_RE = /^[a-z]+:/i;
const PATHNAME_PROTOCOL_RE = /^pathname:\/\//;
const HASH_RE = /#.*$/;
const EXT_RE = /(index|README)?\.(md|html)$/;
const inBrowser = typeof document !== "undefined";
function toArray(value) {
	return Array.isArray(value) ? value : [value];
}
function isActive(currentPath, matchPath, asRegex = false) {
	if (matchPath === void 0) return false;
	currentPath = normalize(`/${currentPath.replace(/^\//, "")}`);
	if (asRegex) return new RegExp(matchPath).test(currentPath);
	if (normalize(matchPath) !== currentPath) return false;
	const hashMatch = matchPath.match(HASH_RE);
	if (hashMatch) return (inBrowser ? location.hash : "") === hashMatch[0];
	return true;
}
function normalize(path) {
	return decodeURI(path).replace(HASH_RE, "").replace(EXT_RE, "");
}
function numToUnit(value) {
	if (typeof value === "undefined") return "";
	if (String(Number(value)) === String(value)) return `${value}px`;
	return value;
}

//#endregion
export { EXTERNAL_URL_RE, EXT_RE, HASH_RE, PATHNAME_PROTOCOL_RE, editLinkPatterns, inBrowser, isActive, normalize, normalizeLink, normalizePrefix, numToUnit, resolveEditLink, resolveNavLink, resolveRepoType, toArray };