import { App, ComputedRef, InjectionKey, MaybeRef, MaybeRefOrGetter, Ref } from "vue";
import { PageDataRef, PageFrontmatterRef, Router, SiteLocaleDataRef, useRoute, useRouter } from "vuepress/client";
import { BlogOptions, BulletinOptions, CopyrightFrontmatter, GitContributor, NavItemWithLink, PresetLocale, ResolvedNavItem, ResolvedSidebarItem, ThemeBlogPostItem, ThemeBlogPostList, ThemeData, ThemeFriendsFrontmatter, ThemeHomeFrontmatter, ThemeHomeHero, ThemeLocaleData, ThemeOutline, ThemePageData, ThemePageFrontmatter, ThemePostFrontmatter, ThemeSidebar, ThemeSidebarItem } from "../../shared/index.js";
import { RouteParamValueRaw } from "vue-router";

//#region src/client/composables/aside.d.ts
declare function useAside(): {
  isAsideEnabled: ComputedRef<boolean>;
};
//#endregion
//#region src/client/composables/blog-archives.d.ts
type ShortPostItem = Pick<ThemeBlogPostItem, "title" | "path" | "createTime">;
interface ArchiveItem {
  title: string;
  label: string;
  list: ShortPostItem[];
}
declare function useArchives(): {
  archives: ComputedRef<ArchiveItem[]>;
};
//#endregion
//#region src/client/composables/blog-category.d.ts
interface CategoryItemWithPost {
  type: "post";
  title: string;
  path: string;
}
interface CategoryItem {
  id: string;
  type: "category";
  sort: number;
  title: string;
  items: (CategoryItem | CategoryItemWithPost)[];
}
type BlogCategory = (CategoryItem | CategoryItemWithPost)[];
declare function useBlogCategory(): {
  categories: ComputedRef<BlogCategory>;
};
//#endregion
//#region src/client/composables/blog-data.d.ts
type BlogDataRef = Ref<ThemeBlogPostList>;
declare const blogPostData: BlogDataRef;
declare function usePostList(): BlogDataRef;
declare function useLocalePostList(): ComputedRef<ThemeBlogPostList>;
//#endregion
//#region src/client/composables/blog-extract.d.ts
interface BlogExtractLink {
  link?: string;
  text?: string;
  total: number;
}
declare function useBlogExtract(): {
  hasBlogExtract: ComputedRef<boolean>;
  tags: ComputedRef<BlogExtractLink>;
  archives: ComputedRef<BlogExtractLink>;
  categories: ComputedRef<BlogExtractLink>;
};
//#endregion
//#region src/client/composables/blog-post-list.d.ts
interface UsePostListControlResult {
  postList: ComputedRef<ThemeBlogPostItem[]>;
  page: Ref<number>;
  totalPage: ComputedRef<number>;
  pageRange: ComputedRef<{
    value: number | string;
    more?: true;
  }[]>;
  isLastPage: ComputedRef<boolean>;
  isFirstPage: ComputedRef<boolean>;
  isPaginationEnabled: ComputedRef<boolean>;
  changePage: (page: number) => void;
}
declare function usePostListControl(homePage: Ref<boolean>): UsePostListControlResult;
//#endregion
//#region src/client/composables/blog-tags.d.ts
type ShortPostItem$1 = Pick<ThemeBlogPostItem, "title" | "path" | "createTime">;
interface BlogTagItem {
  name: string;
  count: string | number;
  className: string;
}
interface UseTagsResult {
  tags: ComputedRef<BlogTagItem[]>;
  currentTag: Ref<string>;
  postList: ComputedRef<ShortPostItem$1[]>;
  handleTagClick: (tag: string) => void;
}
declare function useTags(): UseTagsResult;
//#endregion
//#region src/client/composables/bulletin.d.ts
declare function useBulletin<T extends Record<string, any> = Record<string, any>>(): ComputedRef<BulletinOptions & T | undefined>;
declare function useBulletinControl<T extends Record<string, any> = Record<string, any>>(): {
  bulletin: ComputedRef<BulletinOptions & T | undefined>;
  enableBulletin: ComputedRef<boolean>;
  showBulletin: Ref<boolean>;
  close: () => void;
};
//#endregion
//#region src/client/composables/contributors.d.ts
interface useContributorsResult {
  mode: ComputedRef<"inline" | "block">;
  contributors: ComputedRef<GitContributor[]>;
  hasContributors: ComputedRef<boolean>;
}
declare function useContributors(): useContributorsResult;
//#endregion
//#region src/client/composables/copyright.d.ts
interface useCopyrightResult {
  license: ComputedRef<License>;
  author: ComputedRef<Exclude<CopyrightFrontmatter["author"], string>>;
  hasCopyright: ComputedRef<boolean>;
  creation: ComputedRef<CopyrightFrontmatter["creation"]>;
  creationText: ComputedRef<string>;
  sourceUrl: ComputedRef<string | undefined>;
}
declare function useCopyright(copyright: ComputedRef<CopyrightFrontmatter>): useCopyrightResult;
interface License {
  name: string;
  url?: string;
  icons?: string[];
}
//#endregion
//#region src/client/composables/dark-mode.d.ts
type DarkModeRef = Ref<boolean>;
declare const darkModeSymbol: InjectionKey<DarkModeRef>;
declare function enableTransitions(): boolean;
declare function setupDarkMode(app: App): void;
/**
* Inject dark mode global computed
*/
declare function useDarkMode(): DarkModeRef;
//#endregion
//#region src/client/composables/theme-data.d.ts
type ThemeDataRef<T extends ThemeData = ThemeData> = Ref<T>;
type ThemeLocaleDataRef<T extends ThemeData = ThemeData> = ComputedRef<T>;
declare const themeLocaleDataSymbol: InjectionKey<ThemeLocaleDataRef>;
declare const themeData: ThemeDataRef;
declare function useThemeData<T extends ThemeData = ThemeData>(): ThemeDataRef<T>;
declare function useThemeLocaleData<T extends ThemeData = ThemeData>(): ThemeLocaleDataRef<T>;
declare function setupThemeData(app: App): void;
//#endregion
//#region src/client/composables/data.d.ts
type FrontmatterType = "home" | "post" | "friends" | "page";
type Frontmatter<T extends FrontmatterType = "page"> = T extends "home" ? ThemeHomeFrontmatter : T extends "post" ? ThemePostFrontmatter : T extends "friends" ? ThemeFriendsFrontmatter : ThemePageFrontmatter;
interface Data<T extends FrontmatterType = "page"> {
  theme: ThemeLocaleDataRef<ThemeLocaleData>;
  page: PageDataRef<ThemePageData>;
  frontmatter: PageFrontmatterRef<Frontmatter<T> & Record<string, unknown>>;
  blog: Ref<BlogOptions>;
  lang: Ref<string>;
  site: SiteLocaleDataRef;
  isDark: Ref<boolean>;
}
declare function useData<T extends FrontmatterType = "page">(): Data<T>;
//#endregion
//#region src/client/composables/edit-link.d.ts
declare function useEditLink(): ComputedRef<null | NavItemWithLink>;
//#endregion
//#region src/client/composables/encrypt-data.d.ts
type EncryptConfig = readonly [boolean, string, string, string[], Record<string, string>];
interface EncryptDataRule {
  key: string;
  match: string;
  rules: string[];
}
interface EncryptData {
  global: boolean;
  separator: string;
  admins: string[];
  matches: string[];
  ruleList: EncryptDataRule[];
}
type EncryptRef = Ref<EncryptData>;
declare const encrypt: EncryptRef;
declare function useEncryptData(): EncryptRef;
//#endregion
//#region src/client/composables/encrypt.d.ts
interface Encrypt {
  hasPageEncrypt: Ref<boolean>;
  isGlobalDecrypted: Ref<boolean>;
  isPageDecrypted: Ref<boolean>;
  hashList: Ref<EncryptDataRule[]>;
}
declare const EncryptSymbol: InjectionKey<Encrypt>;
declare function setupEncrypt(): void;
declare function useEncrypt(): Encrypt;
declare function useEncryptCompare(): {
  compareGlobal: (password: string) => Promise<boolean>;
  comparePage: (password: string) => Promise<boolean>;
};
//#endregion
//#region src/client/composables/flyout.d.ts
interface UseFlyoutOptions {
  el: Ref<HTMLElement | undefined>;
  onFocus?: () => void;
  onBlur?: () => void;
}
declare const focusedElement: Ref<HTMLElement | undefined>;
declare function useFlyout(options: UseFlyoutOptions): Readonly<Ref<boolean>>;
//#endregion
//#region src/client/composables/home.d.ts
interface TintPlate {
  r: {
    value: number;
    offset: number;
  };
  g: {
    value: number;
    offset: number;
  };
  b: {
    value: number;
    offset: number;
  };
}
declare function useHomeHeroTintPlate(canvas: Ref<HTMLCanvasElement | undefined>, enable: Ref<boolean>, tintPlate: Ref<ThemeHomeHero["tintPlate"]>): void;
//#endregion
//#region src/client/composables/icons.d.ts
type IconsData = Record<string, string>;
type IconsDataRef = Ref<IconsData>;
declare const useIconsData: () => IconsDataRef;
//#endregion
//#region src/client/composables/internal-link.d.ts
interface InternalLink {
  text: string;
  link: string;
}
declare function useInternalLink(): {
  home: ComputedRef<InternalLink>;
  blog: ComputedRef<InternalLink>;
  tags: ComputedRef<InternalLink | undefined>;
  archive: ComputedRef<InternalLink | undefined>;
  categories: ComputedRef<InternalLink | undefined>;
};
//#endregion
//#region src/client/composables/langs.d.ts
interface Lang {
  label?: string;
  link: string;
}
interface UseLangOptions {
  removeCurrent?: boolean;
}
interface UseLangResult {
  localeLinks: ComputedRef<Lang[]>;
  currentLang: ComputedRef<Lang>;
}
declare function useLangs({
  removeCurrent
}?: UseLangOptions): UseLangResult;
//#endregion
//#region src/client/composables/latest-updated.d.ts
declare function useLastUpdated(): {
  datetime: Ref<string>;
  isoDatetime: ComputedRef<string | undefined>;
  lastUpdatedText: ComputedRef<string>;
};
//#endregion
//#region src/client/composables/link.d.ts
interface UseLinkResult {
  /**
  * 外部链接
  */
  isExternal: ComputedRef<boolean>;
  /**
  * 外部链接协议
  * 此项不包含 target="_blank" 的情况
  */
  isExternalProtocol: ComputedRef<boolean>;
  link: ComputedRef<string | undefined>;
}
declare function useLink(href: MaybeRefOrGetter<string | undefined>, target?: MaybeRefOrGetter<string | undefined>): UseLinkResult;
//#endregion
//#region src/client/composables/nav.d.ts
declare function useNavbarData(): Ref<ResolvedNavItem[]>;
interface UseNavReturn {
  isScreenOpen: Ref<boolean>;
  openScreen: () => void;
  closeScreen: () => void;
  toggleScreen: () => void;
}
declare function useNav(): UseNavReturn;
//#endregion
//#region src/client/composables/outline.d.ts
interface Header {
  /**
  * The level of the header
  *
  * `1` to `6` for `<h1>` to `<h6>`
  */
  level: number;
  /**
  * The title of the header
  */
  title: string;
  /**
  * The slug of the header
  *
  * Typically the `id` attr of the header anchor
  */
  slug: string;
  /**
  * Link of the header
  *
  * Typically using `#${slug}` as the anchor hash
  */
  link: string;
  /**
  * The children of the header
  */
  children: Header[];
}
type MenuItem = Omit<Header, "slug" | "children"> & {
  element: HTMLHeadElement;
  children?: MenuItem[];
};
declare const headersSymbol: InjectionKey<Ref<MenuItem[]>>;
declare function setupHeaders(): Ref<MenuItem[]>;
declare function useHeaders(): Ref<MenuItem[]>;
declare function getHeaders(range?: ThemeOutline): MenuItem[];
declare function resolveHeaders(headers: MenuItem[], range?: ThemeOutline): MenuItem[];
declare function useActiveAnchor(container: Ref<HTMLElement | null>, marker: Ref<HTMLElement | null>): void;
//#endregion
//#region src/client/composables/page.d.ts
declare function useBlogPageData(): {
  isBlogPost: ComputedRef<boolean>;
  isBlogLayout: ComputedRef<boolean>;
};
//#endregion
//#region src/client/composables/preset-locales.d.ts
interface PresetLocales {
  [locale: string]: PresetLocale;
}
declare const presetLocales: PresetLocales;
declare function getPresetLocaleData(locale: string, name: keyof PresetLocale): string;
//#endregion
//#region src/client/composables/prev-next.d.ts
interface UsePrevNextResult {
  prev: ComputedRef<NavItemWithLink | null>;
  next: ComputedRef<NavItemWithLink | null>;
}
declare function usePrevNext(): UsePrevNextResult;
//#endregion
//#region src/client/composables/route-query.d.ts
type RouteQueryValueRaw = RouteParamValueRaw | string[];
interface ReactiveRouteOptions {
  /**
  * Mode to update the router query, ref is also acceptable
  *
  * @default 'replace'
  */
  mode?: MaybeRef<"replace" | "push">;
  /**
  * Route instance, use `useRoute()` if not given
  */
  route?: ReturnType<typeof useRoute>;
  /**
  * Router instance, use `useRouter()` if not given
  */
  router?: ReturnType<typeof useRouter>;
}
interface ReactiveRouteOptionsWithTransform<V, R> extends ReactiveRouteOptions {
  /**
  * Function to transform data before return
  */
  transform?: (val: V) => R;
}
declare function useRouteQuery(name: string): Ref<null | string | string[]>;
declare function useRouteQuery<T extends RouteQueryValueRaw = RouteQueryValueRaw, K = T>(name: string, defaultValue?: MaybeRefOrGetter<T>, options?: ReactiveRouteOptionsWithTransform<T, K>): Ref<K>;
//#endregion
//#region src/client/composables/scroll-behavior.d.ts
declare function enhanceScrollBehavior(router: Router): void;
//#endregion
//#region src/client/composables/scroll-promise.d.ts
interface ScrollPromise {
  wait: () => Promise<void> | null;
  pending: () => void;
  resolve: () => void;
}
declare const useScrollPromise: () => ScrollPromise;
//#endregion
//#region src/client/composables/sidebar.d.ts
type SidebarData = Record<string, ThemeSidebar>;
type SidebarDataRef = Ref<SidebarData>;
type AutoDirSidebarRef = Ref<ThemeSidebarItem[] | {
  link: string;
  items: ThemeSidebarItem[];
}>;
type AutoHomeDataRef = Ref<Record<string, string>>;
declare function setupSidebar(): void;
declare function useSidebarData(): Ref<ResolvedSidebarItem[]>;
/**
* Get the `Sidebar` from sidebar option. This method will ensure to get correct
* sidebar config from `MultiSideBarConfig` with various path combinations such
* as matching `guide/` and `/guide/`. If no matching config was found, it will
* return empty array.
*/
declare function getSidebar(routePath: string, routeLocal: string): ResolvedSidebarItem[];
/**
* Get or generate sidebar group from the given sidebar items.
*/
declare function getSidebarGroups(sidebar: ResolvedSidebarItem[]): ResolvedSidebarItem[];
/**
* Check if the given sidebar item contains any active link.
*/
declare function hasActiveLink(path: string, items: ResolvedSidebarItem | ResolvedSidebarItem[]): boolean;
interface SidebarControl {
  collapsed: Ref<boolean>;
  collapsible: ComputedRef<boolean>;
  isLink: ComputedRef<boolean>;
  isActiveLink: Ref<boolean>;
  hasActiveLink: ComputedRef<boolean>;
  hasChildren: ComputedRef<boolean>;
  toggle: () => void;
}
interface UseSidebarReturn {
  isOpen: Ref<boolean>;
  sidebar: Ref<ResolvedSidebarItem[]>;
  sidebarKey: Ref<string>;
  sidebarGroups: Ref<ResolvedSidebarItem[]>;
  hasSidebar: ComputedRef<boolean>;
  hasAside: ComputedRef<boolean>;
  leftAside: ComputedRef<boolean>;
  isSidebarEnabled: ComputedRef<boolean>;
  open: () => void;
  close: () => void;
  toggle: () => void;
}
declare function useSidebar(): UseSidebarReturn;
/**
* a11y: cache the element that opened the Sidebar (the menu button) then
* focus that button again when Menu is closed with Escape key.
*/
declare function useCloseSidebarOnEscape(isOpen: Ref<boolean>, close: () => void): void;
declare function useSidebarControl(item: ComputedRef<ResolvedSidebarItem>): SidebarControl;
declare function getSidebarFirstLink(sidebar: ResolvedSidebarItem[]): string;
//#endregion
//#region src/client/composables/tag-colors.d.ts
type TagColors = Record<string, string>;
type TagColorsRef = Ref<TagColors>;
declare const useTagColors: () => TagColorsRef;
//#endregion
//#region src/client/composables/watermark.d.ts
declare function setupWatermark(): void;
//#endregion
export { AutoDirSidebarRef, AutoHomeDataRef, BlogCategory, BlogDataRef, CategoryItem, CategoryItemWithPost, Data, Encrypt, EncryptConfig, EncryptData, EncryptDataRule, EncryptRef, EncryptSymbol, Header, InternalLink, MenuItem, ReactiveRouteOptions, ReactiveRouteOptionsWithTransform, RouteQueryValueRaw, ScrollPromise, ShortPostItem, SidebarControl, SidebarData, SidebarDataRef, TagColors, TagColorsRef, ThemeDataRef, ThemeLocaleDataRef, TintPlate, UseNavReturn, UseSidebarReturn, blogPostData, darkModeSymbol, enableTransitions, encrypt, enhanceScrollBehavior, focusedElement, getHeaders, getPresetLocaleData, getSidebar, getSidebarFirstLink, getSidebarGroups, hasActiveLink, headersSymbol, presetLocales, resolveHeaders, setupDarkMode, setupEncrypt, setupHeaders, setupSidebar, setupThemeData, setupWatermark, themeData, themeLocaleDataSymbol, useActiveAnchor, useArchives, useAside, useBlogCategory, useBlogExtract, useBlogPageData, useBulletin, useBulletinControl, useCloseSidebarOnEscape, useContributors, useCopyright, useDarkMode, useData, useEditLink, useEncrypt, useEncryptCompare, useEncryptData, useFlyout, useHeaders, useHomeHeroTintPlate, useIconsData, useInternalLink, useLangs, useLastUpdated, useLink, useLocalePostList, useNav, useNavbarData, usePostList, usePostListControl, usePrevNext, useRouteQuery, useScrollPromise, useSidebar, useSidebarControl, useSidebarData, useTagColors, useTags, useThemeData, useThemeLocaleData };