import { addViteConfig, configWebpack, getBundlerName, isArray, isFunction, removeEndingSlash, removeLeadingSlash } from "@vuepress/helper";
import { createVitePlugin as createVitePlugin$1, createWebpackPlugin as createWebpackPlugin$1 } from "unplugin";
import MagicString from "magic-string";

//#region src/constants.ts
const PLUGIN_NAME = "vuepress-plugin-replace-assets";
const KNOWN_IMAGE_EXTENSIONS = [
	"png",
	"jpg",
	"jpeg",
	"gif",
	"webp",
	"svg",
	"avif"
];
const KNOWN_MEDIA_EXTENSIONS = [
	"mp4",
	"webm",
	"ogg",
	"mp3",
	"wav",
	"flac",
	"aac",
	"m3u8",
	"m3u",
	"flv",
	"pdf"
];
const KNOWN_ASSET_EXTENSIONS = [...KNOWN_IMAGE_EXTENSIONS, ...KNOWN_MEDIA_EXTENSIONS];

//#endregion
//#region src/normalizeRules.ts
function createFindPattern(extensions) {
	return /* @__PURE__ */ new RegExp(`\\.(?:${extensions.join("|")})(\\?.*)?$`);
}
function normalizeRules(options) {
	const normalized = [];
	if (typeof options === "string" || isFunction(options)) {
		options && normalized.push({
			find: createFindPattern(KNOWN_ASSET_EXTENSIONS),
			replacement: options
		});
		return normalized;
	}
	if (isArray(options)) {
		normalized.push(...options);
		return normalized;
	}
	if ("find" in options) {
		options.find && options.replacement && normalized.push(options);
		return normalized;
	}
	if (options.image) normalized.push({
		find: createFindPattern(KNOWN_IMAGE_EXTENSIONS),
		replacement: options.image
	});
	if (options.media) normalized.push({
		find: createFindPattern(KNOWN_MEDIA_EXTENSIONS),
		replacement: options.media
	});
	if (options.all) normalized.push({
		find: createFindPattern(KNOWN_ASSET_EXTENSIONS),
		replacement: options.all
	});
	if (options.rules) normalized.push(...isArray(options.rules) ? options.rules : [options.rules]);
	return normalized;
}

//#endregion
//#region src/unplugin/utils.ts
function createAssetPattern(prefix) {
	const s = `(${prefix}.*?)`;
	return new RegExp([
		`(?:"${s}")`,
		`(?:'${s}')`,
		`(?:\\(${s}\\))`,
		`(?:\\('${s}'\\))`,
		`(?:\\("${s}"\\))`,
		`(?:\\\\"${s}\\\\")`
	].join("|"), "gu");
}
function normalizeUrl(url, base) {
	if (!url) return "";
	if (base) url = `${removeEndingSlash(base)}/${removeLeadingSlash(url)}`;
	return url;
}

//#endregion
//#region src/unplugin/transform.ts
const cache = /* @__PURE__ */ new Map();
function transformAssets(code, pattern, rules) {
	const s = new MagicString(code);
	let matched;
	let hasMatched = false;
	while (matched = pattern.exec(code)) {
		const assetUrl = matched[6] || matched[5] || matched[4] || matched[3] || matched[2] || matched[1];
		const [left, right] = matched[0].startsWith("(") ? ["(\"", "\")"] : matched[0].startsWith("\\\"") ? ["\\\"", "\\\""] : ["\"", "\""];
		const start = matched.index;
		const end = start + matched[0].length;
		const resolved = replacementAssetWithRules(rules, assetUrl);
		if (resolved) {
			hasMatched = true;
			s.update(start, end, `${left}${resolved}${right}`);
		}
	}
	if (!hasMatched) return code;
	return s.toString();
}
function replacementAssetWithRules(rules, url) {
	if (cache.has(url)) return cache.get(url);
	for (const { find, replacement } of rules) if (find && isMatchUrl(find, url)) {
		let replaced = "";
		if (typeof replacement === "function") replaced = normalizeUrl(replacement(url));
		else replaced = normalizeUrl(url, replacement);
		/* istanbul ignore if -- @preserve */
		if (replaced) {
			cache.set(url, replaced);
			return replaced;
		}
	}
	return void 0;
}
function isMatchUrl(find, url) {
	if (typeof find === "string") if (find[0] === "^" || find[find.length - 1] === "$") return new RegExp(find).test(url);
	else return url.endsWith(find) || url.startsWith(find);
	return find.test(url);
}

//#endregion
//#region src/unplugin/factory.ts
const unpluginFactory = (rules) => {
	const pattern = createAssetPattern("/[^/]");
	return {
		name: "vuepress:replace-assets",
		enforce: "pre",
		transform: {
			filter: { id: { exclude: [/\.json(?:$|\?)/, /\.html?$/] } },
			handler(code) {
				return transformAssets(code, pattern, rules);
			}
		}
	};
};

//#endregion
//#region src/unplugin/index.ts
const createVitePlugin = () => createVitePlugin$1(unpluginFactory);
const createWebpackPlugin = () => createWebpackPlugin$1(unpluginFactory);

//#endregion
//#region src/plugin.ts
const EMPTY_PLUGIN = { name: PLUGIN_NAME };
function replaceAssetsPlugin(options = {}) {
	const rules = normalizeRules(options);
	if (rules.length === 0) return EMPTY_PLUGIN;
	return {
		...EMPTY_PLUGIN,
		extendsBundlerOptions(bundlerOptions, app) {
			const bundle = getBundlerName(app);
			if (bundle === "vite") {
				const replaceAssets = createVitePlugin();
				addViteConfig(bundlerOptions, app, { plugins: [replaceAssets(rules)] });
			}
			if (bundle === "webpack") {
				const replaceAssets = createWebpackPlugin();
				configWebpack(bundlerOptions, app, (config) => {
					config.plugins ??= [];
					config.plugins.push(replaceAssets(rules));
				});
			}
		}
	};
}

//#endregion
export { createFindPattern, createVitePlugin, createWebpackPlugin, isMatchUrl, normalizeRules, replaceAssetsPlugin, replacementAssetWithRules, transformAssets };